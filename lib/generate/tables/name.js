'use strict';

// See documentation here: http://www.microsoft.com/typography/otspec/name.htm

var _ = require('underscore');
var ByteBuffer = require('../byte_buffer.js');
var Str = require('../str.js');

var TTF_NAMES = {
    copyright: 0,
    fontFamily: 1,
    fontSubfamily : 2,
    uniqueID: 3,
    fullName: 4,
    version : 5,

    description: 10,
    url: 11
};

function tableSize(names) {
    var result = 6; // table header
    _.forEach(names, function (name) {
        result += 12 + name.data.length; //name header and data
    });
    return result;
}

function getStrings(name, id) {
    var result = [];
    var str = new Str(name);
    result.push({ data: str.toUTF8Bytes(), id: id, platformID: 1, encodingID: 0, languageID: 0 }); //mac standard
    result.push({ data: str.toUCS2Bytes(), id: id, platformID: 3, encodingID: 1, languageID: 0x409 }); //windows standard
    return result;
}

// Collect font names
function getNames(names) {
    var result = [];

    ['copyright', 'fontFamily', 'uniqueID', 'fontSubfamily', 'licence'].forEach(function(n) {
        if(names[n]) {
            result.push(getStrings(names[n], TTF_NAMES[n]));
        }
    });

    result.push(getStrings('Generated by node-freetype.', TTF_NAMES.description));
    result.push(getStrings('https://github.com/YuhangGe/node-freetype', TTF_NAMES.url));

    result.sort(function (a, b) {
        var orderFields = ['platformID', 'encodingID', 'languageID', 'id'];
        var i;
        for (i = 0; i < orderFields.length; i++) {
            if (a[orderFields[i]] !== b[orderFields[i]]) {
                return a[orderFields[i]] < b[orderFields[i]] ? -1 : 1;
            }
        }
        return 0;
    });

    return result;
}

function createNameTable(font) {

    var names = getNames(font.tables.name);

    var buf = ByteBuffer.prototype.create(tableSize(names));

    buf.writeUint16(0); // formatSelector
    buf.writeUint16(names.length); // nameRecordsCount
    var offsetPosition = buf.tell();
    buf.writeUint16(0); // offset, will be filled later
    var nameOffset = 0;
    _.forEach(names, function (name) {
        buf.writeUint16(name.platformID); // platformID
        buf.writeUint16(name.encodingID); // platEncID
        buf.writeUint16(name.languageID); // languageID, English (USA)
        buf.writeUint16(name.id); // nameID
        buf.writeUint16(name.data.length); // reclength
        buf.writeUint16(nameOffset); // offset
        nameOffset += name.data.length;
    });
    var actualStringDataOffset = buf.tell();
    //Array of bytes with actual string data
    _.forEach(names, function (name) {
        buf.writeBytes(name.data);
    });

    //write actual string data offset
    buf.seek(offsetPosition);
    buf.writeUint16(actualStringDataOffset); // offset

    return buf;
}

module.exports = createNameTable;
